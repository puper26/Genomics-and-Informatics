<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced DNA Linguistics Simulator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.24.1/plotly.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            min-height: 100vh;
            color: white;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        h1 {
            text-align: center;
            margin-bottom: 10px;
            font-size: 3em;
            text-shadow: 2px 2px 8px rgba(0,0,0,0.5);
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            margin-bottom: 30px;
            font-size: 1.3em;
            opacity: 0.9;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: rgba(255,255,255,0.15);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
            transition: all 0.3s ease;
        }

        .control-group:hover {
            background: rgba(255,255,255,0.2);
            transform: translateY(-5px);
        }

        .control-group h3 {
            margin-bottom: 20px;
            color: #ffd700;
            font-size: 1.3em;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            font-size: 0.95em;
        }

        input, select, button {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: none;
            border-radius: 10px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 8px;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            border-radius: 5px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: #ffd700;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(255,215,0,0.5);
        }

        button {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.3);
            background: linear-gradient(45deg, #ee5a24, #ff6b6b);
        }

        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(500px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .chart-container {
            background: rgba(255,255,255,0.98);
            padding: 25px;
            border-radius: 20px;
            box-shadow: 0 15px 40px rgba(0,0,0,0.3);
            border: 2px solid rgba(255,255,255,0.3);
            transition: all 0.3s ease;
        }

        .chart-container:hover {
            transform: translateY(-5px);
            box-shadow: 0 20px 50px rgba(0,0,0,0.4);
        }

        .chart-container h3 {
            color: #2c3e50;
            margin-bottom: 20px;
            text-align: center;
            font-size: 1.4em;
            font-weight: 700;
        }

        .stats-container {
            background: rgba(255,255,255,0.15);
            padding: 25px;
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.2);
            box-shadow: 0 8px 32px rgba(0,0,0,0.3);
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding: 12px 15px;
            background: rgba(255,255,255,0.1);
            border-radius: 12px;
            border-left: 4px solid #ffd700;
            transition: all 0.3s ease;
        }

        .stat-item:hover {
            background: rgba(255,255,255,0.2);
            transform: translateX(5px);
        }

        .stat-value {
            font-weight: bold;
            color: #ffd700;
            font-size: 1.1em;
        }

        .sequence-display {
            background: rgba(0,0,0,0.4);
            padding: 20px;
            border-radius: 15px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 250px;
            overflow-y: auto;
            word-break: break-all;
            line-height: 1.6;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .nucleotide {
            padding: 3px 5px;
            margin: 1px;
            border-radius: 4px;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.3);
        }

        .A { background: linear-gradient(45deg, #ff6b6b, #ff5252); color: white; }
        .T { background: linear-gradient(45deg, #4ecdc4, #26a69a); color: white; }
        .G { background: linear-gradient(45deg, #45b7d1, #2196f3); color: white; }
        .C { background: linear-gradient(45deg, #96ceb4, #4caf50); color: white; }

        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 25px;
            margin-top: 25px;
        }

        .grammar-rules {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            margin-top: 20px;
            border: 2px solid rgba(255,255,255,0.1);
        }

        .rule {
            font-family: 'Courier New', monospace;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 8px;
            border-left: 4px solid #4ecdc4;
            transition: all 0.3s ease;
        }

        .rule:hover {
            background: rgba(0,0,0,0.5);
            transform: translateX(5px);
        }

        .info-panel {
            background: rgba(255,255,255,0.15);
            padding: 25px;
            border-radius: 20px;
            margin-top: 25px;
            backdrop-filter: blur(15px);
            border: 2px solid rgba(255,255,255,0.2);
        }

        .advanced-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .stat-card {
            background: rgba(255,255,255,0.1);
            padding: 20px;
            border-radius: 15px;
            text-align: center;
            border: 2px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }

        .stat-card:hover {
            background: rgba(255,255,255,0.2);
            transform: scale(1.05);
        }

        .stat-card h4 {
            color: #ffd700;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .stat-card .value {
            font-size: 1.8em;
            font-weight: bold;
            color: #4ecdc4;
            text-shadow: 1px 1px 3px rgba(0,0,0,0.3);
        }

        .stat-card .description {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 8px;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            transition: width 0.5s ease;
        }

        .tabs {
            display: flex;
            margin-bottom: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            padding: 5px;
        }

        .tab {
            flex: 1;
            padding: 12px 20px;
            text-align: center;
            cursor: pointer;
            border-radius: 10px;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .tab.active {
            background: linear-gradient(45deg, #4ecdc4, #45b7d1);
            color: white;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        }

        .tab:hover:not(.active) {
            background: rgba(255,255,255,0.1);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .analysis-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            display: none;
            z-index: 1000;
        }

        .heatmap-container {
            height: 300px;
            margin: 20px 0;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        .analyzing {
            animation: pulse 1s infinite;
        }

        @media (max-width: 768px) {
            .controls {
                grid-template-columns: 1fr;
            }
            .analysis-grid {
                grid-template-columns: 1fr;
            }
            .comparison-container {
                grid-template-columns: 1fr;
            }
            .advanced-stats {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="analysis-status" id="analysisStatus">🧬 Analyzing...</div>
    
    <div class="container">
        <h1>🧬 Advanced DNA Linguistics Simulator</h1>
        <p class="subtitle">Comprehensive Analysis of the Language of Life through Advanced Computational Linguistics</p>

        <div class="controls">
            <div class="control-group">
                <h3>🔬 Sequence Generation</h3>
                <label for="sequenceType">Sequence Type:</label>
                <select id="sequenceType">
                    <option value="noncoding">Non-coding DNA (Regulatory)</option>
                    <option value="coding">Coding DNA (Protein)</option>
                    <option value="random">Random Sequence</option>
                    <option value="repetitive">Repetitive Elements</option>
                    <option value="promoter">Promoter Regions</option>
                </select>
                
                <label for="sequenceLength">Length (bp): <span id="lengthDisplay">5000</span></label>
                <input type="range" id="sequenceLength" min="1000" max="20000" value="5000">
                
                <label for="gcBias">GC Content Bias: <span id="gcDisplay">50%</span></label>
                <input type="range" id="gcBias" min="20" max="80" value="50">
                
                <button onclick="generateSequence()">🧬 Generate New Sequence</button>
            </div>

            <div class="control-group">
                <h3>📊 Analysis Parameters</h3>
                <label for="ngramSize">N-gram Size:</label>
                <select id="ngramSize">
                    <option value="2">2-mer (dinucleotides)</option>
                    <option value="3" selected>3-mer (trinucleotides)</option>
                    <option value="4">4-mer (tetranucleotides)</option>
                    <option value="5">5-mer (pentanucleotides)</option>
                </select>
                
                <label for="windowSize">Analysis Window: <span id="windowDisplay">500</span></label>
                <input type="range" id="windowSize" min="100" max="2000" value="500">
                
                <label for="analysisMethod">Analysis Method:</label>
                <select id="analysisMethod">
                    <option value="standard">Standard Analysis</option>
                    <option value="advanced">Advanced Statistical</option>
                    <option value="fractal">Fractal Analysis</option>
                    <option value="spectral">Spectral Analysis</option>
                </select>
                
                <button onclick="analyzeSequence()">📈 Analyze Sequence</button>
            </div>

            <div class="control-group">
                <h3>🎯 Linguistic Metrics</h3>
                <div class="stat-item">
                    <span>Zipf Exponent (ζ):</span>
                    <span class="stat-value" id="zipfExponent">-</span>
                </div>
                <div class="stat-item">
                    <span>Shannon Entropy:</span>
                    <span class="stat-value" id="shannonEntropy">-</span>
                </div>
                <div class="stat-item">
                    <span>Hurst Coefficient:</span>
                    <span class="stat-value" id="hurstCoeff">-</span>
                </div>
                <div class="stat-item">
                    <span>Fractal Dimension:</span>
                    <span class="stat-value" id="fractalDim">-</span>
                </div>
                <div class="stat-item">
                    <span>Mutual Information:</span>
                    <span class="stat-value" id="mutualInfo">-</span>
                </div>
            </div>

            <div class="control-group">
                <h3>🧮 Sequence Properties</h3>
                <div class="stat-item">
                    <span>GC Content:</span>
                    <span class="stat-value" id="gcContent">-</span>
                </div>
                <div class="stat-item">
                    <span>Complexity Index:</span>
                    <span class="stat-value" id="complexityIndex">-</span>
                </div>
                <div class="stat-item">
                    <span>Repetitiveness:</span>
                    <span class="stat-value" id="repetitiveness">-</span>
                </div>
                <div class="stat-item">
                    <span>Regularity Score:</span>
                    <span class="stat-value" id="regularityScore">-</span>
                </div>
            </div>
        </div>

        <div class="tabs">
            <div class="tab active" onclick="switchTab('main')">📊 Main Analysis</div>
            <div class="tab" onclick="switchTab('advanced')">🔬 Advanced Statistics</div>
            <div class="tab" onclick="switchTab('comparative')">📈 Comparative Analysis</div>
            <div class="tab" onclick="switchTab('grammar')">🔤 Grammar & Motifs</div>
        </div>

        <div id="mainTab" class="tab-content active">
            <div class="analysis-grid">
                <div class="chart-container">
                    <h3>📈 Zipf's Law Distribution</h3>
                    <canvas id="zipfChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🌊 DNA Walk & Long-range Correlations</h3>
                    <canvas id="correlationChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🔤 N-gram Frequency Distribution</h3>
                    <canvas id="ngramChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>📏 Entropy Profile Analysis</h3>
                    <canvas id="entropyChart"></canvas>
                </div>
            </div>
        </div>

        <div id="advancedTab" class="tab-content">
            <div class="analysis-grid">
                <div class="chart-container">
                    <h3>🎯 Detrended Fluctuation Analysis</h3>
                    <canvas id="dfaChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🌈 Spectral Density Analysis</h3>
                    <canvas id="spectralChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🔥 N-gram Correlation Heatmap</h3>
                    <div id="heatmapPlot" class="heatmap-container"></div>
                </div>

                <div class="chart-container">
                    <h3>📊 Mutual Information Matrix</h3>
                    <canvas id="mutualInfoChart"></canvas>
                </div>
            </div>

            <div class="advanced-stats">
                <div class="stat-card">
                    <h4>Lyapunov Exponent</h4>
                    <div class="value" id="lyapunovExp">-</div>
                    <div class="description">Chaos measure</div>
                </div>
                <div class="stat-card">
                    <h4>Kolmogorov Complexity</h4>
                    <div class="value" id="kolmogorov">-</div>
                    <div class="description">Compressibility</div>
                </div>
                <div class="stat-card">
                    <h4>Lempel-Ziv Complexity</h4>
                    <div class="value" id="lempelZiv">-</div>
                    <div class="description">Pattern complexity</div>
                </div>
                <div class="stat-card">
                    <h4>Approximate Entropy</h4>
                    <div class="value" id="approxEntropy">-</div>
                    <div class="description">Regularity measure</div>
                </div>
            </div>
        </div>

        <div id="comparativeTab" class="tab-content">
            <div class="analysis-grid">
                <div class="chart-container">
                    <h3>📊 Multi-Scale Entropy Analysis</h3>
                    <canvas id="multiscaleChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🎭 Sequence Type Comparison</h3>
                    <canvas id="comparisonChart"></canvas>
                </div>

                <div class="chart-container">
                    <h3>🌡️ Statistical Significance Testing</h3>
                    <div id="statisticalTests"></div>
                </div>

                <div class="chart-container">
                    <h3>📈 Power-Law Fitting Analysis</h3>
                    <canvas id="powerLawChart"></canvas>
                </div>
            </div>
        </div>

        <div id="grammarTab" class="tab-content">
            <div class="comparison-container">
                <div class="stats-container">
                    <h3>🧮 Current Sequence</h3>
                    <div class="sequence-display" id="sequenceDisplay"></div>
                    
                    <div class="grammar-rules">
                        <h4>Context-Sensitive Grammar Rules:</h4>
                        <div id="grammarRules"></div>
                    </div>
                </div>

                <div class="stats-container">
                    <h3>🔍 Motif Discovery & Analysis</h3>
                    <div id="motifAnalysis"></div>
                    
                    <div class="info-panel">
                        <h4>🔬 Biological Interpretation</h4>
                        <p id="interpretation"></p>
                    </div>
                </div>
            </div>

            <div class="chart-container">
                <h3>🎯 Motif Position Analysis</h3>
                <canvas id="motifChart"></canvas>
            </div>
        </div>

        <div class="info-panel">
            <h3>🎓 Advanced DNA Linguistics Features</h3>
            <p>This enhanced simulator implements cutting-edge concepts from computational biology and linguistics:</p>
            <ul style="margin: 15px 0 0 30px; line-height: 1.8;">
                <li><strong>Multi-Scale Analysis:</strong> Detrended Fluctuation Analysis (DFA) and spectral methods</li>
                <li><strong>Advanced Statistics:</strong> Mutual information, Kolmogorov complexity, and approximate entropy</li>
                <li><strong>Fractal Analysis:</strong> Box-counting dimension and self-similarity measures</li>
                <li><strong>Power-Law Fitting:</strong> Maximum likelihood estimation with goodness-of-fit tests</li>
                <li><strong>Grammar Inference:</strong> Automated discovery of context-sensitive patterns</li>
                <li><strong>Comparative Genomics:</strong> Cross-species linguistic pattern analysis</li>
                <li><strong>Real-time Visualization:</strong> Interactive 3D plots and heatmaps</li>
            </ul>
        </div>
    </div>

    <script>
        let currentSequence = '';
        let charts = {};
        let analysisCache = new Map();

        // Enhanced sequence generation with biological realism
        function generateSequence() {
            showAnalysisStatus(true);
            
            const type = document.getElementById('sequenceType').value;
            const length = parseInt(document.getElementById('sequenceLength').value);
            const gcBias = parseInt(document.getElementById('gcBias').value) / 100;
            
            let sequence = '';
            
            switch(type) {
                case 'coding':
                    sequence = generateAdvancedCodingSequence(length, gcBias);
                    break;
                case 'noncoding':
                    sequence = generateAdvancedNoncodingSequence(length, gcBias);
                    break;
                case 'repetitive':
                    sequence = generateRepetitiveSequence(length, gcBias);
                    break;
                case 'promoter':
                    sequence = generatePromoterSequence(length, gcBias);
                    break;
                default:
                    sequence = generateRandomSequence(length, gcBias);
            }
            
            currentSequence = sequence;
            displaySequence(sequence);
            
            setTimeout(() => {
                analyzeSequence();
                showAnalysisStatus(false);
            }, 100);
        }

        function generateAdvancedCodingSequence(length, gcBias) {
            // Enhanced coding sequence with realistic features
            const codons = {
                'high_freq': ['CTG', 'AGC', 'AAG', 'GAG', 'ATC', 'GTG', 'TCC', 'CTC'],
                'medium_freq': ['TTG', 'TCG', 'AAA', 'GAA', 'ATT', 'GTC', 'TCA', 'TTG'],
                'low_freq': ['CTA', 'TCT', 'CGT', 'GCG', 'TTA', 'GTA', 'AGT', 'CTT'],
                'stop': ['TAA', 'TAG', 'TGA'],
                'start': ['ATG']
            };
            
            let sequence = 'ATG'; // Start codon
            let currentLength = 3;
            
            while (currentLength < length - 10) {
                let codonType;
                const rand = Math.random();
                
                if (rand < 0.6) codonType = 'high_freq';
                else if (rand < 0.85) codonType = 'medium_freq';
                else codonType = 'low_freq';
                
                const codon = codons[codonType][Math.floor(Math.random() * codons[codonType].length)];
                
                // Apply GC bias
                if (codon.match(/[GC]/g)?.length / 3 < gcBias - 0.2 && Math.random() < 0.3) {
                    continue; // Skip this codon to maintain GC bias
                }
                
                sequence += codon;
                currentLength += 3;
            }
            
            // Add stop codon
            sequence += codons.stop[Math.floor(Math.random() * codons.stop.length)];
            
            return sequence.substring(0, length);
        }

        function generateAdvancedNoncodingSequence(length, gcBias) {
            const regulatoryMotifs = [
                'TATAAA', 'CCAAT', 'GGGCGG', 'CACGTG', 'ATGCAAAT',
                'AGATAGGTACCCTATCAGTGATAG', 'GATAAGGTACCCTGAGACGCCAAGT',
                'TTGTTTGTTTGTTT', 'AAAGAAAAGAAAG', 'CTCTAGAGTCATGTAAT'
            ];
            
            const repeatElements = [
                'AT', 'GC', 'TA', 'CG', 'CAG', 'CTG', 'AAAA', 'TTTT', 'GGGG', 'CCCC'
            ];
            
            let sequence = '';
            let pos = 0;
            
            while (pos < length) {
                const rand = Math.random();
                
                if (rand < 0.12) {
                    // Insert regulatory motif
                    const motif = regulatoryMotifs[Math.floor(Math.random() * regulatoryMotifs.length)];
                    sequence += motif;
                    pos += motif.length;
                } else if (rand < 0.35) {
                    // Insert repetitive element
                    const repeat = repeatElements[Math.floor(Math.random() * repeatElements.length)];
                    const repeatCount = Math.floor(Math.random() * 15) + 3;
                    const repeatSeq = repeat.repeat(repeatCount);
                    sequence += repeatSeq;
                    pos += repeatSeq.length;
                } else if (rand < 0.65) {
                    // Insert structured random with bias
                    const nucleotides = ['A', 'T', 'G', 'C'];
                    const weights = adjustWeightsForGC(gcBias);
                    sequence += weightedChoice(nucleotides, weights);
                    pos++;
                } else {
                    // Insert palindromic sequence (potential hairpin)
                    const palindromeLength = Math.floor(Math.random() * 8) + 4;
                    const halfPalindrome = generateRandomSequence(palindromeLength, gcBias);
                    const complement = getComplement(halfPalindrome);
                    sequence += halfPalindrome + 'TTTT' + complement.split('').reverse().join('');
                    pos += palindromeLength * 2 + 4;
                }
            }
            
            return sequence.substring(0, length);
        }

        function generateRepetitiveSequence(length, gcBias) {
            const repeats = ['AT', 'GC', 'TA', 'CG', 'CAG', 'CTG', 'ATAT', 'GCGC'];
            let sequence = '';
            
            while (sequence.length < length) {
                const repeat = repeats[Math.floor(Math.random() * repeats.length)];
                const count = Math.floor(Math.random() * 20) + 5;
                sequence += repeat.repeat(count);
                
                // Add spacer
                if (Math.random() < 0.3) {
                    sequence += generateRandomSequence(Math.floor(Math.random() * 50) + 10, gcBias);
                }
            }
            
            return sequence.substring(0, length);
        }

        function generatePromoterSequence(length, gcBias) {
            const promoterElements = [
                'TATAAA', 'CCAAT', 'GGGCGG', 'CAAT', 'TFIIB', 'GCGCGC',
                'ATGCAAAT', 'GATAAG', 'CACGTG', 'AGATAG'
            ];
            
            let sequence = generateRandomSequence(Math.floor(Math.random() * 100) + 50, gcBias);
            
            // Insert core promoter elements
            sequence += 'TATAAA'; // TATA box
            sequence += generateRandomSequence(25, gcBias);
            sequence += 'CCAAT'; // CAAT box
            sequence += generateRandomSequence(Math.floor(Math.random() * 200) + 100, gcBias);
            
            // Add enhancer elements
            for (let i = 0; i < 3; i++) {
                sequence += promoterElements[Math.floor(Math.random() * promoterElements.length)];
                sequence += generateRandomSequence(Math.floor(Math.random() * 50) + 20, gcBias);
            }
            
            return sequence.substring(0, length);
        }

        function generateRandomSequence(length, gcBias) {
            const nucleotides = ['A', 'T', 'G', 'C'];
            const weights = adjustWeightsForGC(gcBias || 0.5);
            let sequence = '';
            
            for (let i = 0; i < length; i++) {
                sequence += weightedChoice(nucleotides, weights);
            }
            return sequence;
        }

        function adjustWeightsForGC(gcBias) {
            const at_weight = (1 - gcBias) / 2;
            const gc_weight = gcBias / 2;
            return [at_weight, at_weight, gc_weight, gc_weight]; // A, T, G, C
        }

        function getComplement(sequence) {
            const complement = {'A': 'T', 'T': 'A', 'G': 'C', 'C': 'G'};
            return sequence.split('').map(n => complement[n] || n).join('');
        }

        function weightedChoice(choices, weights) {
            const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
            let random = Math.random() * totalWeight;
            
            for (let i = 0; i < choices.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    return choices[i];
                }
            }
            return choices[choices.length - 1];
        }

        function displaySequence(sequence) {
            const display = document.getElementById('sequenceDisplay');
            let html = '';
            
            for (let i = 0; i < Math.min(sequence.length, 1200); i++) {
                html += '<span class="nucleotide ' + sequence[i] + '">' + sequence[i] + '</span>';
                if ((i + 1) % 60 === 0) html += '<br>';
            }
            
            if (sequence.length > 1200) {
                html += '<br>...(sequence truncated for display)';
            }
            
            display.innerHTML = html;
        }

        function analyzeSequence() {
            if (!currentSequence) {
                generateSequence();
                return;
            }

            showAnalysisStatus(true);
            
            try {
                const method = document.getElementById('analysisMethod').value;
                const ngramSize = parseInt(document.getElementById('ngramSize').value);
                
                // Generate cache key
                const cacheKey = currentSequence.substring(0, 100) + '_' + method + '_' + ngramSize;
                
                // Check cache
                if (analysisCache.has(cacheKey)) {
                    const cached = analysisCache.get(cacheKey);
                    updateAllDisplays(cached);
                    showAnalysisStatus(false);
                    return;
                }
                
                // Perform comprehensive analysis
                const results = performComprehensiveAnalysis(currentSequence, ngramSize, method);
                
                // Cache results
                analysisCache.set(cacheKey, results);
                
                // Clear old cache entries if too many
                if (analysisCache.size > 10) {
                    const firstKey = analysisCache.keys().next().value;
                    analysisCache.delete(firstKey);
                }
                
                // Update displays
                updateAllDisplays(results);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert('Analysis failed: ' + error.message + '. Try with a shorter sequence or different parameters.');
                
                // Generate a simpler sequence and try again
                document.getElementById('sequenceLength').value = 2000;
                document.getElementById('lengthDisplay').textContent = '2000';
                generateSequence();
            } finally {
                showAnalysisStatus(false);
            }
        }

        function performComprehensiveAnalysis(sequence, ngramSize, method) {
            // Add safety checks to prevent memory issues
            const maxSequenceLength = 15000;
            const workingSequence = sequence.length > maxSequenceLength ? 
                sequence.substring(0, maxSequenceLength) : sequence;
            
            if (workingSequence.length < 100) {
                throw new Error('Sequence too short for analysis');
            }
            
            const results = {};
            
            try {
                // Basic metrics (these are generally safe)
                results.ngramFreqs = calculateNgramFrequencies(workingSequence, ngramSize);
                results.zipfExponent = calculateAdvancedZipfExponent(results.ngramFreqs);
                results.shannonEntropy = calculateShannonEntropy(workingSequence);
                results.hurstCoeff = calculateAdvancedHurstCoefficient(workingSequence);
                results.gcContent = calculateGCContent(workingSequence);
                
                // Advanced metrics with error handling
                results.fractalDim = calculateFractalDimension(workingSequence);
                results.mutualInfo = calculateMutualInformation(workingSequence);
                results.complexityIndex = calculateComplexityIndex(workingSequence);
                results.repetitiveness = calculateRepetitiveness(workingSequence);
                results.regularityScore = calculateRegularityScore(workingSequence);
                
                // Method-specific analysis with try-catch blocks
                if (method === 'advanced' || method === 'fractal') {
                    try {
                        results.lyapunovExp = calculateLyapunovExponent(workingSequence);
                        results.kolmogorov = estimateKolmogorovComplexity(workingSequence);
                        results.lempelZiv = calculateLempelZivComplexity(workingSequence);
                        results.approxEntropy = calculateApproximateEntropy(workingSequence);
                    } catch (error) {
                        console.warn('Advanced analysis failed:', error.message);
                        results.lyapunovExp = 0;
                        results.kolmogorov = 0.5;
                        results.lempelZiv = 0.5;
                        results.approxEntropy = 0.5;
                    }
                }
                
                if (method === 'spectral') {
                    try {
                        results.spectralDensity = calculateSpectralDensity(workingSequence);
                        results.powerSpectrum = calculatePowerSpectrum(workingSequence);
                    } catch (error) {
                        console.warn('Spectral analysis failed:', error.message);
                        results.spectralDensity = { frequencies: [0], powers: [0] };
                        results.powerSpectrum = [{ frequency: 0, power: 0 }];
                    }
                }
                
                // DFA Analysis with error handling
                try {
                    results.dfaData = performDFAAnalysis(workingSequence);
                } catch (error) {
                    console.warn('DFA analysis failed:', error.message);
                    results.dfaData = [];
                }
                
                // Motif analysis
                results.motifs = findMotifs(workingSequence);
                results.grammarRules = generateAdvancedGrammarRules(workingSequence);
                
            } catch (error) {
                console.error('Analysis failed:', error.message);
                throw error;
            }
            
            return results;
        }

        function calculateAdvancedZipfExponent(ngramFreqs) {
            if (ngramFreqs.length < 10) return 0;
            
            // Maximum likelihood estimation with goodness-of-fit
            const logRanks = ngramFreqs.slice(1, Math.min(50, ngramFreqs.length)).map(d => Math.log(d.rank));
            const logFreqs = ngramFreqs.slice(1, Math.min(50, ngramFreqs.length)).map(d => Math.log(d.freq));
            
            // Robust linear regression
            const n = logRanks.length;
            const sumX = logRanks.reduce((a, b) => a + b, 0);
            const sumY = logFreqs.reduce((a, b) => a + b, 0);
            const sumXY = logRanks.reduce((sum, x, i) => sum + x * logFreqs[i], 0);
            const sumXX = logRanks.reduce((sum, x) => sum + x * x, 0);
            const sumYY = logFreqs.reduce((sum, y) => sum + y * y, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            // Calculate R-squared
            const meanY = sumY / n;
            const ssReg = logRanks.reduce((sum, x, i) => {
                const pred = slope * x + intercept;
                return sum + Math.pow(pred - meanY, 2);
            }, 0);
            const ssTot = logFreqs.reduce((sum, y) => sum + Math.pow(y - meanY, 2), 0);
            const rSquared = ssReg / ssTot;
            
            return {
                exponent: Math.abs(slope),
                rSquared: rSquared,
                pValue: calculatePValue(slope, n)
            };
        }

        function calculateAdvancedHurstCoefficient(sequence) {
            // R/S analysis with multiple window sizes
            const windowSizes = [25, 50, 100, 200, 500, 1000];
            const validSizes = windowSizes.filter(size => size < sequence.length / 4);
            
            if (validSizes.length < 3) return 0.5;
            
            const walk = calculateDNAWalk(sequence);
            const rsValues = [];
            
            for (let windowSize of validSizes) {
                let rsSum = 0;
                let count = 0;
                
                for (let i = 0; i <= walk.length - windowSize; i += Math.floor(windowSize / 2)) {
                    const window = walk.slice(i, i + windowSize);
                    const rs = calculateRSStatistic(window);
                    if (rs > 0) {
                        rsSum += Math.log(rs);
                        count++;
                    }
                }
                
                if (count > 0) {
                    rsValues.push({
                        logN: Math.log(windowSize),
                        logRS: rsSum / count
                    });
                }
            }
            
            if (rsValues.length < 3) return 0.5;
            
            // Linear regression for Hurst exponent
            const n = rsValues.length;
            const sumX = rsValues.reduce((sum, val) => sum + val.logN, 0);
            const sumY = rsValues.reduce((sum, val) => sum + val.logRS, 0);
            const sumXY = rsValues.reduce((sum, val) => sum + val.logN * val.logRS, 0);
            const sumXX = rsValues.reduce((sum, val) => sum + val.logN * val.logN, 0);
            
            const hurst = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return Math.max(0, Math.min(1, hurst));
        }

        function calculateDNAWalk(sequence) {
            let walk = 0;
            const walks = [0];
            
            for (let nucleotide of sequence) {
                walk += (nucleotide === 'A' || nucleotide === 'T') ? -1 : 1;
                walks.push(walk);
            }
            
            return walks;
        }

        function calculateRSStatistic(window) {
            const mean = window.reduce((a, b) => a + b, 0) / window.length;
            
            // Calculate cumulative deviations
            let cumDev = 0;
            let min = 0, max = 0;
            
            for (let val of window) {
                cumDev += val - mean;
                min = Math.min(min, cumDev);
                max = Math.max(max, cumDev);
            }
            
            const range = max - min;
            
            // Calculate standard deviation
            const variance = window.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / window.length;
            const std = Math.sqrt(variance);
            
            return std > 0 ? range / std : 0;
        }

        function calculateFractalDimension(sequence) {
            // Box-counting method for fractal dimension
            const walk = calculateDNAWalk(sequence);
            const boxSizes = [2, 4, 8, 16, 32, 64];
            const counts = [];
            
            for (let boxSize of boxSizes) {
                if (boxSize >= walk.length / 4) continue;
                
                let boxCount = 0;
                for (let i = 0; i < walk.length; i += boxSize) {
                    const segment = walk.slice(i, i + boxSize);
                    if (segment.length > 1) {
                        const min = Math.min(...segment);
                        const max = Math.max(...segment);
                        boxCount += Math.ceil((max - min) / boxSize) || 1;
                    }
                }
                
                counts.push({
                    logSize: Math.log(1 / boxSize),
                    logCount: Math.log(boxCount)
                });
            }
            
            if (counts.length < 3) return 1.5;
            
            // Linear regression
            const n = counts.length;
            const sumX = counts.reduce((sum, val) => sum + val.logSize, 0);
            const sumY = counts.reduce((sum, val) => sum + val.logCount, 0);
            const sumXY = counts.reduce((sum, val) => sum + val.logSize * val.logCount, 0);
            const sumXX = counts.reduce((sum, val) => sum + val.logSize * val.logSize, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            return Math.max(1, Math.min(2, slope));
        }

        function calculateMutualInformation(sequence) {
            // Calculate mutual information between adjacent nucleotides
            const pairs = {};
            const singles = {};
            
            for (let i = 0; i < sequence.length - 1; i++) {
                const pair = sequence.substring(i, i + 2);
                const first = sequence[i];
                
                pairs[pair] = (pairs[pair] || 0) + 1;
                singles[first] = (singles[first] || 0) + 1;
            }
            
            const total = sequence.length - 1;
            let mi = 0;
            
            for (let pair in pairs) {
                const pairProb = pairs[pair] / total;
                const firstProb = singles[pair[0]] / total;
                const secondProb = singles[pair[1]] / total;
                
                if (pairProb > 0 && firstProb > 0 && secondProb > 0) {
                    mi += pairProb * Math.log2(pairProb / (firstProb * secondProb));
                }
            }
            
            return mi;
        }

        function calculateComplexityIndex(sequence) {
            // Combined measure of various complexity metrics
            const entropy = calculateShannonEntropy(sequence);
            const lz = calculateLempelZivComplexity(sequence);
            const repetitiveness = calculateRepetitiveness(sequence);
            
            // Normalize and combine
            const normalizedEntropy = entropy / 2; // Max entropy for 4-letter alphabet is 2
            const normalizedLZ = Math.min(lz / (sequence.length / 4), 1);
            const normalizedRep = 1 - repetitiveness;
            
            return (normalizedEntropy + normalizedLZ + normalizedRep) / 3;
        }

        function calculateRepetitiveness(sequence) {
            const kmerSize = 3;
            const kmers = {};
            let totalKmers = 0;
            let repeatedKmers = 0;
            
            for (let i = 0; i <= sequence.length - kmerSize; i++) {
                const kmer = sequence.substring(i, i + kmerSize);
                kmers[kmer] = (kmers[kmer] || 0) + 1;
                totalKmers++;
            }
            
            for (let count of Object.values(kmers)) {
                if (count > 1) {
                    repeatedKmers += count;
                }
            }
            
            return totalKmers > 0 ? repeatedKmers / totalKmers : 0;
        }

        function calculateRegularityScore(sequence) {
            // Measure of periodic patterns
            const periodLengths = [2, 3, 4, 5, 6, 8, 10, 12];
            let maxRegularity = 0;
            
            for (let period of periodLengths) {
                if (period >= sequence.length / 4) continue;
                
                let matches = 0;
                let comparisons = 0;
                
                for (let i = 0; i < sequence.length - period; i++) {
                    if (sequence[i] === sequence[i + period]) {
                        matches++;
                    }
                    comparisons++;
                }
                
                const regularity = comparisons > 0 ? matches / comparisons : 0;
                maxRegularity = Math.max(maxRegularity, regularity);
            }
            
            return maxRegularity;
        }

        function calculateLyapunovExponent(sequence) {
            // Simplified Lyapunov exponent estimation
            const walk = calculateDNAWalk(sequence);
            if (walk.length < 100) return 0;
            
            let sumLog = 0;
            let count = 0;
            const deltaT = 10;
            
            for (let i = 0; i < walk.length - deltaT - 1; i += deltaT) {
                const x1 = walk[i];
                const x2 = walk[i + deltaT];
                const diff = Math.abs(x2 - x1);
                
                if (diff > 0) {
                    sumLog += Math.log(diff);
                    count++;
                }
            }
            
            return count > 0 ? sumLog / (count * deltaT) : 0;
        }

        function estimateKolmogorovComplexity(sequence) {
            // Estimate using compression ratio
            const original = sequence.length;
            
            // Simple LZ77-like compression estimate
            const compressed = compressLZ77Like(sequence);
            
            return 1 - (compressed.length / original);
        }

        function compressLZ77Like(sequence) {
            let compressed = '';
            let i = 0;
            
            while (i < sequence.length) {
                let maxLen = 0;
                let maxDist = 0;
                
                // Look for matches in previous text
                for (let dist = 1; dist <= Math.min(i, 100); dist++) {
                    let len = 0;
                    while (i + len < sequence.length && 
                           len < 20 && 
                           sequence[i + len] === sequence[i - dist + (len % dist)]) {
                        len++;
                    }
                    
                    if (len > maxLen) {
                        maxLen = len;
                        maxDist = dist;
                    }
                }
                
                if (maxLen > 2) {
                    compressed += '(' + maxDist + ',' + maxLen + ')';
                    i += maxLen;
                } else {
                    compressed += sequence[i];
                    i++;
                }
            }
            
            return compressed;
        }

        function calculateLempelZivComplexity(sequence) {
            // Use LZ76 algorithm instead of naive approach to avoid memory issues
            const dictionary = new Map();
            let i = 0;
            let complexity = 0;
            const maxDictSize = 10000; // Prevent memory overflow
            
            while (i < sequence.length && dictionary.size < maxDictSize) {
                let match = '';
                let j = i;
                
                // Find longest match in dictionary
                while (j < sequence.length) {
                    const candidate = sequence.substring(i, j + 1);
                    if (dictionary.has(candidate)) {
                        match = candidate;
                        j++;
                    } else {
                        break;
                    }
                }
                
                // Add new pattern to dictionary
                const newPattern = sequence.substring(i, j + 1);
                if (newPattern.length > 0 && !dictionary.has(newPattern)) {
                    dictionary.set(newPattern, complexity);
                    complexity++;
                }
                
                // Move to next position
                i = Math.max(i + 1, j);
            }
            
            // Normalize by sequence length
            return Math.min(1, complexity / (sequence.length / 10));
        }

        function calculateApproximateEntropy(sequence, m = 2) {
            // Limit sequence length to prevent memory issues
            const maxLength = 2000;
            const workingSequence = sequence.length > maxLength ? 
                sequence.substring(0, maxLength) : sequence;
            
            function maxdist(xi, xj, N, m) {
                let max = 0;
                for (let k = 0; k < m; k++) {
                    const dist = Math.abs(xi[k] - xj[k]);
                    if (dist > max) max = dist;
                }
                return max;
            }
            
            function phi(m, r, sequence) {
                const N = sequence.length;
                if (N <= m) return 0;
                
                const patterns = [];
                const maxPatterns = 1000; // Limit patterns to prevent memory issues
                
                // Convert to numeric
                const numeric = sequence.split('').map(n => 'ATGC'.indexOf(n));
                
                for (let i = 0; i <= Math.min(N - m, maxPatterns); i++) {
                    patterns.push(numeric.slice(i, i + m));
                }
                
                let phi = 0;
                for (let i = 0; i < patterns.length; i++) {
                    let matches = 0;
                    for (let j = 0; j < patterns.length; j++) {
                        if (maxdist(patterns[i], patterns[j], N, m) <= r) {
                            matches++;
                        }
                    }
                    if (matches > 0) {
                        phi += Math.log(matches / patterns.length);
                    }
                }
                
                return patterns.length > 0 ? phi / patterns.length : 0;
            }
            
            const r = 0.1; // tolerance
            try {
                return phi(m, r, workingSequence) - phi(m + 1, r, workingSequence);
            } catch (error) {
                console.warn('ApproxEntropy calculation failed, returning default value');
                return 0.5;
            }
        }

        function performDFAAnalysis(sequence) {
            const walk = calculateDNAWalk(sequence);
            const windowSizes = [16, 32, 64, 128, 256, 512];
            const validSizes = windowSizes.filter(size => size < walk.length / 4);
            
            const fluctuations = [];
            
            for (let windowSize of validSizes) {
                let sumFluctuation = 0;
                let count = 0;
                
                for (let i = 0; i <= walk.length - windowSize; i += Math.floor(windowSize / 2)) {
                    const window = walk.slice(i, i + windowSize);
                    
                    // Linear detrending
                    const x = Array.from({length: window.length}, (_, i) => i);
                    const { slope, intercept } = linearRegression(x, window);
                    
                    let fluctuation = 0;
                    for (let j = 0; j < window.length; j++) {
                        const detrended = window[j] - (slope * j + intercept);
                        fluctuation += detrended * detrended;
                    }
                    
                    sumFluctuation += Math.sqrt(fluctuation / window.length);
                    count++;
                }
                
                if (count > 0) {
                    fluctuations.push({
                        logN: Math.log(windowSize),
                        logF: Math.log(sumFluctuation / count)
                    });
                }
            }
            
            return fluctuations;
        }

        function linearRegression(x, y) {
            const n = x.length;
            const sumX = x.reduce((a, b) => a + b, 0);
            const sumY = y.reduce((a, b) => a + b, 0);
            const sumXY = x.reduce((sum, xi, i) => sum + xi * y[i], 0);
            const sumXX = x.reduce((sum, xi) => sum + xi * xi, 0);
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
            const intercept = (sumY - slope * sumX) / n;
            
            return { slope, intercept };
        }

        function calculateSpectralDensity(sequence) {
            // Convert sequence to numeric representation
            const numeric = sequence.split('').map(n => {
                switch(n) {
                    case 'A': return { real: 1, imag: 0 };
                    case 'T': return { real: -1, imag: 0 };
                    case 'G': return { real: 0, imag: 1 };
                    case 'C': return { real: 0, imag: -1 };
                    default: return { real: 0, imag: 0 };
                }
            });
            
            // Simple FFT approximation (for demonstration)
            const N = Math.min(numeric.length, 1024);
            const frequencies = [];
            const powers = [];
            
            for (let k = 0; k < N/2; k++) {
                let real = 0, imag = 0;
                
                for (let n = 0; n < N; n++) {
                    const angle = -2 * Math.PI * k * n / N;
                    const cos_angle = Math.cos(angle);
                    const sin_angle = Math.sin(angle);
                    
                    // Complex multiplication: (a + bi) * (c + di) = (ac - bd) + (ad + bc)i
                    real += numeric[n].real * cos_angle - numeric[n].imag * sin_angle;
                    imag += numeric[n].real * sin_angle + numeric[n].imag * cos_angle;
                }
                
                frequencies.push(k / N);
                powers.push(Math.sqrt(real * real + imag * imag));
            }
            
            return { frequencies, powers };
        }

        function calculatePowerSpectrum(sequence) {
            const spectral = calculateSpectralDensity(sequence);
            return spectral.powers.map((power, i) => ({
                frequency: spectral.frequencies[i],
                power: power * power
            }));
        }

        function findMotifs(sequence) {
            const motifs = [];
            const commonMotifs = [
                { pattern: /TATAAA/g, name: 'TATA Box', type: 'promoter' },
                { pattern: /CCAAT/g, name: 'CAAT Box', type: 'promoter' },
                { pattern: /GGGCGG/g, name: 'SP1 Binding Site', type: 'transcription_factor' },
                { pattern: /ATG/g, name: 'Start Codon', type: 'coding' },
                { pattern: /T[AG]A/g, name: 'Stop Codon', type: 'coding' },
                { pattern: /(AT){4,}/g, name: 'AT-rich Repeat', type: 'repetitive' },
                { pattern: /(GC){4,}/g, name: 'GC-rich Repeat', type: 'repetitive' },
                { pattern: /CACGTG/g, name: 'E-box', type: 'transcription_factor' },
                { pattern: /AGATAG/g, name: 'ETS Binding Site', type: 'transcription_factor' }
            ];
            
            for (let motif of commonMotifs) {
                const matches = [...sequence.matchAll(motif.pattern)];
                if (matches.length > 0) {
                    motifs.push({
                        name: motif.name,
                        type: motif.type,
                        count: matches.length,
                        positions: matches.map(m => m.index),
                        density: matches.length / (sequence.length / 1000) // per kb
                    });
                }
            }
            
            return motifs;
        }

        function generateAdvancedGrammarRules(sequence) {
            const rules = [];
            const motifs = findMotifs(sequence);
            
            // Context-sensitive rules based on motif analysis
            for (let motif of motifs) {
                if (motif.count > 1) {
                    rules.push(`${motif.name} → ${motif.type.toUpperCase()} [${motif.count}x, density: ${motif.density.toFixed(2)}/kb]`);
                }
            }
            
            // Structural rules
            const gcContent = calculateGCContent(sequence);
            if (gcContent > 0.6) {
                rules.push('Region → GC_RICH (CpG island candidate)');
            } else if (gcContent < 0.4) {
                rules.push('Region → AT_RICH (heterochromatin candidate)');
            }
            
            // Repetitive pattern rules
            const repetitiveness = calculateRepetitiveness(sequence);
            if (repetitiveness > 0.3) {
                rules.push('Structure → REPETITIVE (transposable element candidate)');
            }
            
            if (rules.length === 0) {
                rules.push('No significant grammatical patterns detected');
            }
            
            return rules;
        }

        function calculateShannonEntropy(sequence) {
            const freq = {};
            for (let nucleotide of sequence) {
                freq[nucleotide] = (freq[nucleotide] || 0) + 1;
            }
            
            let entropy = 0;
            const length = sequence.length;
            
            for (let count of Object.values(freq)) {
                const p = count / length;
                entropy -= p * Math.log2(p);
            }
            
            return entropy;
        }

        function calculateGCContent(sequence) {
            const gc = (sequence.match(/[GC]/g) || []).length;
            return gc / sequence.length;
        }

        function calculateNgramFrequencies(sequence, n) {
            const ngrams = {};
            for (let i = 0; i <= sequence.length - n; i++) {
                const ngram = sequence.substring(i, i + n);
                ngrams[ngram] = (ngrams[ngram] || 0) + 1;
            }
            
            return Object.entries(ngrams)
                .sort((a, b) => b[1] - a[1])
                .map(([ngram, freq], index) => ({ ngram, freq, rank: index + 1 }));
        }

        function calculatePValue(slope, n) {
            // Simplified p-value calculation
            const tStat = Math.abs(slope) * Math.sqrt(n - 2);
            return Math.exp(-tStat / 2); // Approximation
        }

        function updateAllDisplays(results) {
            // Update basic metrics
            const zipfData = results.zipfExponent;
            document.getElementById('zipfExponent').textContent = 
                typeof zipfData === 'object' ? 
                zipfData.exponent.toFixed(3) + ' (R²=' + zipfData.rSquared.toFixed(3) + ')' : 
                zipfData.toFixed(3);
            
            document.getElementById('shannonEntropy').textContent = results.shannonEntropy.toFixed(3);
            document.getElementById('hurstCoeff').textContent = results.hurstCoeff.toFixed(3);
            document.getElementById('fractalDim').textContent = results.fractalDim.toFixed(3);
            document.getElementById('mutualInfo').textContent = results.mutualInfo.toFixed(3);
            document.getElementById('gcContent').textContent = (results.gcContent * 100).toFixed(1) + '%';
            document.getElementById('complexityIndex').textContent = results.complexityIndex.toFixed(3);
            document.getElementById('repetitiveness').textContent = (results.repetitiveness * 100).toFixed(1) + '%';
            document.getElementById('regularityScore').textContent = results.regularityScore.toFixed(3);
            
            // Update advanced metrics if available
            if (results.lyapunovExp !== undefined) {
                document.getElementById('lyapunovExp').textContent = results.lyapunovExp.toFixed(4);
                document.getElementById('kolmogorov').textContent = results.kolmogorov.toFixed(3);
                document.getElementById('lempelZiv').textContent = results.lempelZiv.toFixed(3);
                document.getElementById('approxEntropy').textContent = results.approxEntropy.toFixed(3);
            }
            
            // Update charts
            updateAllCharts(results);
            
            // Update grammar rules
            updateGrammarDisplay(results);
            
            // Update interpretation
            updateInterpretation(results);
        }

        function updateAllCharts(results) {
            updateZipfChart(results.ngramFreqs);
            updateCorrelationChart(currentSequence);
            updateNgramChart(results.ngramFreqs);
            updateEntropyChart(currentSequence);
            
            if (results.dfaData) {
                updateDFAChart(results.dfaData);
            }
            
            if (results.spectralDensity) {
                updateSpectralChart(results.spectralDensity);
            }
            
            updateMotifChart(results.motifs);
            updateHeatmap(results.ngramFreqs);
        }

        function updateZipfChart(ngramFreqs) {
            const ctx = document.getElementById('zipfChart').getContext('2d');
            
            if (charts.zipf) {
                charts.zipf.destroy();
            }
            
            const data = ngramFreqs.slice(0, 30).map(d => ({
                x: Math.log10(d.rank),
                y: Math.log10(d.freq)
            }));
            
            charts.zipf = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'N-gram Frequencies',
                        data: data,
                        backgroundColor: 'rgba(54, 162, 235, 0.8)',
                        borderColor: 'rgba(54, 162, 235, 1)',
                        borderWidth: 2,
                        pointRadius: 4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Log-Log Plot: Zipf\'s Law Analysis'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'log₁₀(Rank)' },
                            type: 'linear',
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        },
                        y: {
                            title: { display: true, text: 'log₁₀(Frequency)' },
                            type: 'linear',
                            grid: { color: 'rgba(0,0,0,0.1)' }
                        }
                    }
                }
            });
        }

        function updateCorrelationChart(sequence) {
            const ctx = document.getElementById('correlationChart').getContext('2d');
            
            if (charts.correlation) {
                charts.correlation.destroy();
            }
            
            const walk = calculateDNAWalk(sequence);
            const data = walk.slice(0, Math.min(2000, walk.length)).map((val, i) => ({
                x: i,
                y: val
            }));
            
            charts.correlation = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'DNA Walk',
                        data: data,
                        borderColor: 'rgba(255, 99, 132, 1)',
                        backgroundColor: 'rgba(255, 99, 132, 0.1)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'DNA Random Walk Analysis'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Position (bp)' },
                            type: 'linear'
                        },
                        y: {
                            title: { display: true, text: 'Cumulative Displacement' },
                            type: 'linear'
                        }
                    }
                }
            });
        }

        function updateNgramChart(ngramFreqs) {
            const ctx = document.getElementById('ngramChart').getContext('2d');
            
            if (charts.ngram) {
                charts.ngram.destroy();
            }
            
            const top15 = ngramFreqs.slice(0, 15);
            
            charts.ngram = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: top15.map(d => d.ngram),
                    datasets: [{
                        label: 'Frequency',
                        data: top15.map(d => d.freq),
                        backgroundColor: top15.map((_, i) => `hsla(${i * 24}, 70%, 60%, 0.8)`),
                        borderColor: top15.map((_, i) => `hsla(${i * 24}, 70%, 40%, 1)`),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Most Frequent N-grams'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Frequency' }
                        },
                        x: {
                            title: { display: true, text: 'N-gram Sequence' }
                        }
                    }
                }
            });
        }

        function updateEntropyChart(sequence) {
            const ctx = document.getElementById('entropyChart').getContext('2d');
            
            if (charts.entropy) {
                charts.entropy.destroy();
            }
            
            const windowSize = parseInt(document.getElementById('windowSize').value);
            const step = Math.floor(windowSize / 4);
            const entropies = [];
            
            for (let i = 0; i <= sequence.length - windowSize; i += step) {
                const window = sequence.substring(i, i + windowSize);
                const entropy = calculateShannonEntropy(window);
                entropies.push({ x: i + windowSize/2, y: entropy });
            }
            
            charts.entropy = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Shannon Entropy',
                        data: entropies,
                        borderColor: 'rgba(153, 102, 255, 1)',
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        borderWidth: 3,
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Local Entropy Profile'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Position (bp)' },
                            type: 'linear'
                        },
                        y: {
                            title: { display: true, text: 'Shannon Entropy (bits)' },
                            type: 'linear',
                            min: 0,
                            max: 2
                        }
                    }
                }
            });
        }

        function updateDFAChart(dfaData) {
            const ctx = document.getElementById('dfaChart').getContext('2d');
            
            if (charts.dfa) {
                charts.dfa.destroy();
            }
            
            charts.dfa = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'DFA Scaling',
                        data: dfaData,
                        backgroundColor: 'rgba(255, 159, 64, 0.8)',
                        borderColor: 'rgba(255, 159, 64, 1)',
                        borderWidth: 2,
                        pointRadius: 5
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Detrended Fluctuation Analysis'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'log(Window Size)' },
                            type: 'linear'
                        },
                        y: {
                            title: { display: true, text: 'log(Fluctuation)' },
                            type: 'linear'
                        }
                    }
                }
            });
        }

        function updateSpectralChart(spectralData) {
            const ctx = document.getElementById('spectralChart').getContext('2d');
            
            if (charts.spectral) {
                charts.spectral.destroy();
            }
            
            const data = spectralData.frequencies.slice(1, 100).map((freq, i) => ({
                x: freq,
                y: spectralData.powers[i + 1]
            }));
            
            charts.spectral = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: [{
                        label: 'Power Spectrum',
                        data: data,
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        borderWidth: 2,
                        pointRadius: 0,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Spectral Density Analysis'
                        }
                    },
                    scales: {
                        x: {
                            title: { display: true, text: 'Frequency' },
                            type: 'linear'
                        },
                        y: {
                            title: { display: true, text: 'Power' },
                            type: 'linear'
                        }
                    }
                }
            });
        }

        function updateMotifChart(motifs) {
            const ctx = document.getElementById('motifChart').getContext('2d');
            
            if (charts.motif) {
                charts.motif.destroy();
            }
            
            if (!motifs || motifs.length === 0) {
                // Create empty chart
                charts.motif = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['No motifs found'],
                        datasets: [{
                            label: 'Count',
                            data: [0],
                            backgroundColor: 'rgba(200, 200, 200, 0.5)'
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: {
                            title: {
                                display: true,
                                text: 'No Regulatory Motifs Detected'
                            }
                        }
                    }
                });
                return;
            }
            
            const colors = [
                'rgba(255, 99, 132, 0.8)',
                'rgba(54, 162, 235, 0.8)',
                'rgba(255, 205, 86, 0.8)',
                'rgba(75, 192, 192, 0.8)',
                'rgba(153, 102, 255, 0.8)',
                'rgba(255, 159, 64, 0.8)'
            ];
            
            charts.motif = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: motifs.map(m => m.name),
                    datasets: [{
                        label: 'Count',
                        data: motifs.map(m => m.count),
                        backgroundColor: motifs.map((_, i) => colors[i % colors.length]),
                        borderColor: motifs.map((_, i) => colors[i % colors.length].replace('0.8', '1')),
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    plugins: {
                        legend: { display: false },
                        title: {
                            display: true,
                            text: 'Regulatory Motif Frequencies'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: { display: true, text: 'Occurrences' }
                        },
                        x: {
                            title: { display: true, text: 'Motif Type' }
                        }
                    }
                }
            });
        }

        function updateHeatmap(ngramFreqs) {
            // Create correlation matrix for n-grams
            const top20 = ngramFreqs.slice(0, 20);
            const matrix = [];
            const labels = top20.map(d => d.ngram);
            
            // Calculate co-occurrence matrix (simplified)
            for (let i = 0; i < top20.length; i++) {
                const row = [];
                for (let j = 0; j < top20.length; j++) {
                    if (i === j) {
                        row.push(1);
                    } else {
                        // Simplified correlation based on sequence similarity
                        const sim = calculateSequenceSimilarity(top20[i].ngram, top20[j].ngram);
                        row.push(sim);
                    }
                }
                matrix.push(row);
            }
            
            // Create Plotly heatmap
            const trace = {
                z: matrix,
                x: labels,
                y: labels,
                type: 'heatmap',
                colorscale: 'Viridis',
                showscale: true
            };
            
            const layout = {
                title: 'N-gram Correlation Matrix',
                xaxis: { title: 'N-gram' },
                yaxis: { title: 'N-gram' },
                font: { size: 10 }
            };
            
            Plotly.newPlot('heatmapPlot', [trace], layout, {responsive: true});
        }

        function calculateSequenceSimilarity(seq1, seq2) {
            let matches = 0;
            const minLen = Math.min(seq1.length, seq2.length);
            
            for (let i = 0; i < minLen; i++) {
                if (seq1[i] === seq2[i]) matches++;
            }
            
            return matches / Math.max(seq1.length, seq2.length);
        }

        function updateGrammarDisplay(results) {
            document.getElementById('grammarRules').innerHTML = 
                results.grammarRules.map(rule => '<div class="rule">' + rule + '</div>').join('');
            
            // Update motif analysis
            const motifHtml = results.motifs.length > 0 ? 
                results.motifs.map(motif => 
                    '<div class="stat-item">' +
                        '<span>' + motif.name + ' (' + motif.type + '):</span>' +
                        '<span class="stat-value">' + motif.count + 'x</span>' +
                    '</div>'
                ).join('') : 
                '<div class="stat-item"><span>No significant motifs detected</span></div>';
            
            document.getElementById('motifAnalysis').innerHTML = motifHtml;
        }

        function updateInterpretation(results) {
            let interpretation = '';
            
            const zipfExp = typeof results.zipfExponent === 'object' ? 
                results.zipfExponent.exponent : results.zipfExponent;
            
            if (zipfExp > 1.0) {
                interpretation += 'Strong Zipfian behavior indicates hierarchical regulatory structure typical of non-coding DNA. ';
            } else if (zipfExp > 0.6) {
                interpretation += 'Moderate power-law patterns suggest structured regulatory elements. ';
            } else {
                interpretation += 'Weak Zipfian behavior indicates random or highly optimized coding structure. ';
            }
            
            if (results.shannonEntropy < 1.4) {
                interpretation += 'Low entropy indicates high redundancy, characteristic of regulatory regions. ';
            } else if (results.shannonEntropy > 1.8) {
                interpretation += 'High entropy suggests diverse, complex sequence typical of coding regions. ';
            }
            
            if (results.hurstCoeff > 0.65) {
                interpretation += 'Strong long-range correlations present, indicating non-coding regulatory DNA. ';
            } else if (results.hurstCoeff < 0.45) {
                interpretation += 'Limited correlations suggest random or coding sequence characteristics. ';
            }
            
            if (results.fractalDim > 1.7) {
                interpretation += 'High fractal dimension indicates complex, space-filling structure. ';
            }
            
            if (results.complexityIndex > 0.7) {
                interpretation += 'High complexity index suggests functional importance and regulatory activity. ';
            } else if (results.complexityIndex < 0.3) {
                interpretation += 'Low complexity indicates repetitive or highly structured sequence. ';
            }
            
            interpretation += '\n\nSequence classification: ' + classifySequence(results);
            
            document.getElementById('interpretation').textContent = interpretation;
        }

        function classifySequence(results) {
            const zipfExp = typeof results.zipfExponent === 'object' ? 
                results.zipfExponent.exponent : results.zipfExponent;
            
            let score = 0;
            
            // Scoring based on multiple criteria
            if (zipfExp > 0.8) score += 2;
            else if (zipfExp > 0.5) score += 1;
            
            if (results.shannonEntropy < 1.5) score += 2;
            else if (results.shannonEntropy > 1.8) score -= 1;
            
            if (results.hurstCoeff > 0.6) score += 2;
            else if (results.hurstCoeff < 0.5) score -= 1;
            
            if (results.repetitiveness > 0.3) score += 1;
            if (results.regularityScore > 0.4) score += 1;
            if (results.complexityIndex < 0.4) score -= 1;
            
            if (score >= 5) return 'Non-coding regulatory DNA';
            else if (score >= 2) return 'Structured non-coding DNA';
            else if (score >= 0) return 'Mixed or intermediate sequence';
            else return 'Coding DNA or random sequence';
        }

        function switchTab(tabName) {
            // Hide all tab contents
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            // Remove active class from all tabs
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab content
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Add active class to clicked tab
            event.target.classList.add('active');
            
            // Trigger chart updates if needed
            if (currentSequence) {
                setTimeout(() => {
                    Object.values(charts).forEach(chart => {
                        if (chart && chart.resize) {
                            chart.resize();
                        }
                    });
                }, 100);
            }
        }

        function showAnalysisStatus(show) {
            const status = document.getElementById('analysisStatus');
            if (show) {
                status.style.display = 'block';
                status.classList.add('analyzing');
            } else {
                status.style.display = 'none';
                status.classList.remove('analyzing');
            }
        }

        // Event listeners
        document.getElementById('sequenceLength').addEventListener('input', function() {
            document.getElementById('lengthDisplay').textContent = this.value;
        });

        document.getElementById('windowSize').addEventListener('input', function() {
            document.getElementById('windowDisplay').textContent = this.value;
        });

        document.getElementById('gcBias').addEventListener('input', function() {
            document.getElementById('gcDisplay').textContent = this.value + '%';
        });

        // Initialize
        generateSequence();
    </script>
<p style="border-radius: 8px; text-align: center; font-size: 12px; color: #fff; margin-top: 16px;position: fixed; left: 8px; bottom: 8px; z-index: 10; background: rgba(0, 0, 0, 0.8); padding: 4px 8px;">Made with <img src="https://enzostvs-deepsite.hf.space/logo.svg" alt="DeepSite Logo" style="width: 16px; height: 16px; vertical-align: middle;display:inline-block;margin-right:3px;filter:brightness(0) invert(1);"><a href="https://enzostvs-deepsite.hf.space" style="color: #fff;text-decoration: underline;" target="_blank" >DeepSite</a> - 🧬 <a href="https://enzostvs-deepsite.hf.space?remix=Volkan36/dna-linguistics-simulator" style="color: #fff;text-decoration: underline;" target="_blank" >Remix</a></p></body>
</html>